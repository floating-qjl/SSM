
IoC(Inversion of Control)控制反转:
  使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转

Spring技术对IoC思想进行了实现
  Spring提供了一个容器，称为IoC容器，用来充当IoC思想中的外部
  IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为Bean

DI(Dependency Injection)依赖注入
  在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入




bean别名配置:

类别           描述

名称           name
类型           属性
所属           bean标签
功能           定义bean的别名，可定义多个，使用逗号(,)分号(;)空格()分隔

范例:
  <bean id="bookDao" name="dao bookDaoImpl" class="com.itheima.dao.imp1.BookDaoImpl"/>
  <bean name="service,bookServiceImpl" class="com.itheima.service.impl.BookServiceImpl"/>

注意事项:
  获取bean无论是通过id还是name获取，如果无法获取到，将抛出异常NoSuchBeanDefinitionException
  NoSuchBeanDefinitionException: No bean named 'bookServiceImpl' available




bean作用范围配置:

类别            描述

名称            scope
类型            属性
所属            bean标签

                定义bean的作用范围，可选范围如下:
功能            singletpn: 单例（默认)
                prototype: 非单例


范例:
  <bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl" scope="prototype"/>

若为非单例，则可控制同一个bean生成的对象是否为同一个






bean实例化：
bean本质上就是对象，创建bean使用构造方法完成


实例化bean的三种方式——构造方法（常用)：

提供可访问的构造方法:
  public class BookDaoImpl implements BookDao {
    public BookDaoImpl(){
      System.out.println( "book constructor is running ...");
    }
    public void save(){
        System.out.println( "book dao save ..." );
    }
  }

配置:
  <bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl"/>

注意：无参构造方法如果不存在，将抛出异常BeanCreationException




实例化bean的三种方式——静态工厂(了解):

静态工厂:
  public class OrderDaoFactory {
    public static OrderDao getOrderDao(){
      return new OrderDaoImpl();
    }
  }
配置
  <bean id="orderDao" factory-method="getOrderDao" class="com.itheima.factory.OrderDaoFactory"/>




实例化bean的三种方式——实例工厂(了解):

实例工厂:
  public class UserDaoFactory{
    public userDao getUserDao(){
      return new UserDaoImpl();
    }
  }

配置:
  <bean id="userDaoFactory" class="com.itheima.factory.UserDaoFactory" />
  <bean id="userDao" factory-method="getUserDao" factory-bean="userDaoFactory"/>




实例化bean的第四种方式——FactoryBean

FactoryBean:
  public class UserDaoFactoryBean implements FactoryBean<UserDao>{
    public UserDao get0bject() throws Exception {
      return new UserDaoImp1();
    }
    public class<?> getobjectType() {
      return UserDao.class;
    }
  }

配置:
  <bean id="userDao" class="com.itheima.factory.UserDaoFactoryBean"/>





bean生命周期:
  生命周期: 从创建到消亡的完整过程
  bean生命周期: bean从创建到销毁的整体过程
  bean生命周期控制: 在bean创建后到销毁前做一些事情

使用bean:
  1.执行业务操作

关闭/销毁容器:
  1.执行bean销毁方法







提供生命周期控制方法:
  public class BookDaoImpl implements BookDao {
    public void save(){
      System.out.println( "book dao save ..." );
    }
    public void init(){
    System.out.println( "book init ..." );
    }
    public void destory(){
      System.out.println( "book destory ... " );
    }
}

配置生命周期控制方法:
  <bean id= "bookDao" class="com.itheima.dao.imp1.BookDaoImp1" init-method="init" destroy-method= "destroy">




bean销毁时机:

容器关闭前触发bean的销毁
关闭容器方式:
  手工关闭容器
    ConfigurableApplicationContext接口close()操作
  注册关闭钩子，在虚拟机退出前先关闭容器再退出虚拟机
    ConfigurableApplicationContext接口registerShutdownHook()操作

public class AppForLifecycle {
  public static void main(String[] args){
    ClassPathXmlApplicationContext ctx = new ClassPathxmlApplicationContext("applicationContext.xml");
    ctx.close();
  }
}








依赖注入方式：

setter注入：
  简单类型：
    在bean中定义引用类型属性并提供可访问的set方法
      public class BookDaoImpl implements BookDao {
        private int connectionNumber;
        public void setConnectionNumber(int connectionNumber) {
          this.connectionNumber = connectionNumber;
        }
      }

      配置中使用property标签value属性注入简单类型数据
      <bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl">
        <property name="connectionNumber" value="10"/>
      </bean>


  引用类型：
    在bean中定义引用类型属性并提供可访问的set方法
    public class BookServiceImpl implements BookService{
      private BookDao bookDao;
      public void setBookDao(BookDao bookDao){
        this.bookDao = bookDao;
      }
    }

    配置中使用property标签ref属性注入引用类型对象
    <bean id="bookService" class="com.itheima.service.imp1.BookServiceImpl"
      <property name="bookDao" ref="bookDao"/>
    </bean>
    <bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl"/>



构造器注入：
  简单类型:
    在bean中定义引用类型属性并提供可访问的set方法
      public class BookDaoImpl implements BookDao {
        private int connectionNumber;
        public void setConnectionNumber( int connectionNumber) {
          this.connectionNumber = connectionNumber;
        }
      }

    配置中使用constructor-arg标签value属性注入简单类型数据
      <bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl">
        <constructor-arg name="connectionNumber" value="10" />
      </bean>



  引用类型:
    在bean中定义引用类型属性并提供可访问的构造方法
      public class BookServiceImpl implements BookService{
        private BookDao bookDao;
        public BookServiceImp1(BookDao bookDao) {
         this.bookDao = bookDao;
        }
      } 

    配置中使用constructor-arg标签ref属性注入引用类型对象
      <bean id="bookService" class="com.itheima.service.impl.BookServiceImpl">
        <constructor-arg name="bookDao" ref="bookDao"/>
      </bean>
      <bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl"/>



    参数适配：
      配置中使用constructor-arg标签type属性设置按形参类型注入
        <bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl">
          <constructor-arg type="int" value="10"/>
          <constructor-arg type="java.lang.String" value="mysql"/>
        </bean>

      配置中使用constructor-arg标签index属性设置按形参位置注入
        <bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl">
          <constructor-arg index="e" value="10"/>
          <constructor-arg index="1" value="mysq1"/>
        </bean>
    




依赖注入方法选择：

1．强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现
2．可选依赖使用setter注入进行，灵活性强
3. Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨
4．如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入
5．实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入
6．自己开发的模块推荐使用setter注入








依赖自动装配：

IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配
自动装配方式：
    按类型(常用)
    按名称
    按构造方法
    不启用自动装配




配置中使用bean标签autowire属性设置自动装配的类型:
    <bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl"/>
    <bean id="bookService" class="com.itheima.service.imp1.BookServiceImpl" autowire="byType"/>


注意事项：
  1.自动装配用于引用类型依赖注入，不能对简单类型进行操作
  2.使用按类型装配时(byType)，必须保障容器中相同类型的bean唯一，推荐使用
  3.使用按名称装配时(byName)，必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用
  4.自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效






注入集合对象：

注入数组对象
  <property name="array">
    <array>
      <value>100</value>
      <value>200</value>
      <value>300</value>
    </array>
  </property>

注入List对象（重点)
  <property name="list">
    <list>
      <value>itcast</value>
      <value>itheima</value>
      <value>boxuegu</value>
    </list>
  </property>

注入Set对象
  <property name="set">
    <set>
      <value>itcast</value>
      <value>itheima</value>
      <value>boxuegu</value>
    </set>
  </property>

注入Map对象（重点）
  <property name="map">
    <map>
      <entry key="country" value="china"/>
      <entry key="province" value="henan"/>
      <entry key="city" value="kaifeng"/>
    </map>
  </property>

注入Properties对象
  <property name="properties">
    <props>
      <prop key="country">china</prop>
      <prop key="province">henan</prop>
      <prop key="city">kaifeng</prop>
    </props>
  </property>






数据源对象管理:

导入druid坐标
  <dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.16</version>
  </dependency>

配置数据源对象作为spring管理的bean
  <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://127.0.0.1:3306/spring_db"/>
    <property name="username" value="root"/>
    <property name="password" value="root"/>
  </bean>





加载properties文件

开启context命名空间：
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns :xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:context="http://www.springframework.org/schema/context"
         xsi:schemaLocation="
            http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd">

使用context命名空间，加载指定properties文件
  <context:property-placeholder location="jdbc.properties"/>

使用$(}读取加载的属性值
<property name="username" value="${jdbc.username}"/>



注意：

不加载系统属性（防止系统内部环境变量重名导致冲突）
  <context:property-placeholder location="jdbc.properties" system-properties-mode="NEVER"/>
加载多个properties文件
  <context:property-placeholder location="jdbc.properties,msg.properties"/>
加载所有properties文件
  <context :property-placeholder location="*.properties"/>
加载properties文件标准格式
  <context:property-placeholder location="classpath:*.properties"/>
从类路径或jar包中搜索并加载properties文件
  <context:property-placeholder location="classpath*:*.properties"/>




创建容器：

方式一:类路径加载配置文件
  ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
方式二︰文件路径加载配置文件
  ApplicationContext ctx = new FileSystemXmlApplicationContext("D:\lapplicationContext.xm1");
加载多个配置文件
  ApplicationContext ctx = new ClassPath×mlApplicationContext("bean1.xml","bean2.xml");



获取bean：

方式一︰使用bean名称获取
  BookDao bookDao =(BookDao)ctx.getBean("bookDao");
方式二︰使用bean名称获取并指定类型
  BookDao bookDao = ctx.getBean("bookDao", BookDao.class);
方式三︰使用bean类型获
  BookDao bookDao = ctx.getBean(BookDao.class);




BeanFactory初始化

类路径加载配置文件:
  Resource resources = new ClassPathResource("applicationContext.xml");
  BeanFactory bf = new Xm1BeanFactory(resources) ;
  BookDao bookDao = bf.getBean("bookDao",BookDao.class);
  bookDao.save();

BeanFactory创建完毕后，所有的bean均为延迟加载





容器相关：

  BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载
  ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载
  ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能
  ApplicationContext接口常用初始化类
    ClassPathXmlApplicationContext
    FileSystemXmlApplicationContext




纯注解开发：
  Spring3.0开启了纯注解开发模式，使用Java类替代配置文件，开启了Spring快速开发赛道
  Java类代替Spring核心配置文件，


@Configuration
@ComponentScan("com.itheima")
public class SpringConfig{
}


注意：
@Configuration注解用于设定当前类为配置类
@ComponentScan注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式

例如：ComponentScan({com.itheima.service","com.itheima.dao"})



读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象
//加载配置文件初始化容器
ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
//加载配置类初始化容器
ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);




使用@scope定义bean作用范围
@Repository
@Scope("singleton")
public class BookDaoImpl implements BookDao {
}



使用@PostConstruct、@PreDestroy定义bean生命周期
@Repository
@Scope("singleton")
public class BookDaoImpl implements BookDao {
  public BookDaoImpl() {
    System.out.println("book dag constructor ...");
  }

  @PostConstruct
  public void init(){
    System.out.println( "book init ..." );
  }

  @PreDestroy
  public void destroy()i
    System.out.print1n(" book destory ..." );
  }
}


























































